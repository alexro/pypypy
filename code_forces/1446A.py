def select(f, i, j, nw):
    if nw[i] > j:
        f[i][j] = 0
    else:
        w1 = f[i-1][j] + nw[i]
        if w1 <= j:
            f[i][j] = w1
        else:
            f[i][j] = nw[i]


def find(n, w, nw):
    w = w // 2
    nw = [0] + nw
    print(nw)
    f = [[0] * (w + 1) for k in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, w + 1):
            select(f, i, j, nw)
    for y in f:
        print(y)


def test():
    # print(find(6, 2, [19, 8, 19, 69, 9, 4]))
    # print(find(1, 3, [3]))
    print(find(7, 12, [1, 1, 1, 17, 1, 1, 1]))


test()

'''
kawetsq
3
1 3
3
6 2
19 8 19 69 9 4
7 12
1 1 1 17 1 1 1

Рюкзак

Входные данные

Каждый тест содержит несколько наборов входных данных. В первой строке указано количество наборов входных данных t
(1≤t≤104

). Описание наборов входных данных приведено ниже.

Первая строка каждого набора входных данных содержит целые числа n
и W (1≤n≤200000, 1≤W≤1018

).

Вторая строка каждого набора входных данных содержит n
целых чисел w1,w2,…,wn (1≤wi≤109

) — веса элементов.

Сумма n
по всем наборам входных данных не превышает 200000

.
Выходные данные

Для каждого набора входных данных, если нет решения, выведите одно целое число −1

.

Если есть решение, состоящее из m
предметов, выведите m в первой строке и m целых чисел j1, j2, ..., jm (1≤ji≤n, где все ji

попарно различны) во второй строке  — индексы предметов, которые вы хотели бы упаковать в рюкзак.

Если есть несколько возможных списков предметов, удовлетворяющих условиям, то можно вывести любой. Обратите внимание, что вы не должны максимизировать сумму весов элементов в рюкзаке.
'''
